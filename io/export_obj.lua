-- export_obj.lua
-- OBJ file export for voxel models

local exportOBJ = {}

-- Lazy loader for voxelGenerator to avoid circular deps
local function getVoxelGenerator()
  return AseVoxel.render.voxel_generator
end

-- REPLACED exportOBJ: adds Y-axis inversion (sprite Y-down -> OBJ Y-up)
function exportOBJ.export(voxels, filePath, options)
  local voxelGenerator = getVoxelGenerator()
  options = options or {}
  local scale = options.scaleModel or 1.0
  local includeColors = (options.includeColors ~= false)
  local useMaterials = (options.colorFormat or "materials") == "materials"

  -- Bounds for Y inversion (Aseprite Y-down -> OBJ Y-up)
  local bounds = voxelGenerator.calculateModelBounds(voxels)
  local minY, maxY = bounds.minY, bounds.maxY
  local heightSpan = maxY - minY

  local f = io.open(filePath, "w")
  if not f then return false, "Cannot open OBJ file" end
  f:write("# Exported from AseVoxel\n")

  local mtlFile
  local materialMap = {}
  local matCount = 0

  if includeColors and useMaterials then
    local mtlPath = app.fs.joinPath(app.fs.filePath(filePath), "voxel_export.mtl")
    f:write("mtllib voxel_export.mtl\n")
    mtlFile = io.open(mtlPath, "w")
    mtlFile:write("# Materials generated by AseVoxel\n")
  end

  -- Cube vertex layout (unit cube centered at origin)
  local CUBE_VERTS = {
    {-0.5,-0.5,-0.5}, { 0.5,-0.5,-0.5}, { 0.5, 0.5,-0.5}, {-0.5, 0.5,-0.5}, -- back
    {-0.5,-0.5, 0.5}, { 0.5,-0.5, 0.5}, { 0.5, 0.5, 0.5}, {-0.5, 0.5, 0.5}, -- front
  }

  -- Face definitions (each quad in CCW order)
  local FACES = {
    {4,3,2,1, normal={ 0, 0,-1}}, -- back
    {5,6,7,8, normal={ 0, 0, 1}}, -- front
    {2,3,7,6, normal={ 1, 0, 0}}, -- right
    {1,5,8,4, normal={-1, 0, 0}}, -- left
    {4,8,7,3, normal={ 0, 1, 0}}, -- top
    {1,2,6,5, normal={ 0,-1, 0}}, -- bottom
  }

  -- Write shared normals
  for _, face in ipairs(FACES) do
    local n = face.normal
    f:write(string.format("vn %.4f %.4f %.4f\n", n[1], n[2], n[3]))
  end

  local vertOffset = 0
  for _, v in ipairs(voxels) do
    local x = v.x * scale
    local y = ((heightSpan - (v.y - minY)) + minY) * scale
    local z = v.z * scale
    local r = (v.color.r or 255)
    local g = (v.color.g or 255)
    local b = (v.color.b or 255)

    local matName
    if includeColors and useMaterials then
      local key = string.format("%d_%d_%d", r, g, b)
      matName = materialMap[key]
      if not matName then
        matCount = matCount + 1
        matName = "voxel_" .. matCount
        materialMap[key] = matName
        if mtlFile then
          mtlFile:write("newmtl "..matName.."\n")
          mtlFile:write(string.format("Kd %.4f %.4f %.4f\n", r/255, g/255, b/255))
          mtlFile:write("d 1.0\nillum 2\n\n")
        end
      end
    end

    if matName then
      f:write("usemtl "..matName.."\n")
    end

    -- write cube vertices
    for _, cv in ipairs(CUBE_VERTS) do
      f:write(string.format("v %.4f %.4f %.4f\n",
        x + cv[1]*scale, y + cv[2]*scale, z + cv[3]*scale))
    end

    -- write faces referencing shared normals (vn indices 1..6)
    for faceIndex, face in ipairs(FACES) do
      local vi = {}
      for _, idx in ipairs(face) do
        table.insert(vi, string.format("%d//%d", vertOffset + idx, faceIndex))
      end
      f:write("f "..table.concat(vi," ").."\n")
    end

    vertOffset = vertOffset + 8
  end

  if mtlFile then mtlFile:close() end
  f:close()
  return true
end

return exportOBJ
