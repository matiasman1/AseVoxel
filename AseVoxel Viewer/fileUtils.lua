-- fileUtils.lua
local fileUtils = {}

-- We need to cache the previewRenderer module since it might be required multiple times
local previewRenderer = nil

-- Helper function to get previewRenderer (lazy loading)
local function getPreviewRenderer()
  if not previewRenderer then
    previewRenderer = require("previewRenderer")
  end
  return previewRenderer
end

--------------------------------------------------------------------------------
-- Export the voxel model to a generic 3D format
-- @param voxels The voxel model to export
-- @param filePath Output file path
-- @param options Optional export options
-- @return Boolean indicating success or failure
--------------------------------------------------------------------------------
function fileUtils.exportGeneric(voxels, filePath, options)
  options = options or {}
  
  -- Default options
  local scaleModel = options.scaleModel or 1.0
  local format = options.format or app.fs.fileExtension(filePath):lower()
  
  -- Ensure file has the correct extension
  if not filePath:lower():match("%." .. format .. "$") then
    filePath = filePath .. "." .. format
  end
  
  if format == "obj" then
    -- For OBJ format, use the exportOBJ function in previewRenderer
    return getPreviewRenderer().exportOBJ(voxels, filePath, options)
  elseif format == "ply" then
    return fileUtils.exportPLY(voxels, filePath, options)
  elseif format == "stl" then
    return fileUtils.exportSTL(voxels, filePath, options)
  else
    -- Unsupported format - try obj as fallback
    app.alert("Unsupported export format '" .. format .. "'. Using OBJ format instead.")
    return getPreviewRenderer().exportOBJ(voxels, filePath:gsub("%.[^%.]+$", ".obj"), options)
  end
end

--------------------------------------------------------------------------------
-- Export the voxel model to PLY format
-- @param voxels The voxel model to export
-- @param filePath Output file path for the PLY file
-- @param options Optional export options
-- @return Boolean indicating success or failure
--------------------------------------------------------------------------------
function fileUtils.exportPLY(voxels, filePath, options)
  options = options or {}
  local scaleModel = options.scaleModel or 1.0
  if not filePath:lower():match("%.ply$") then
    filePath = filePath .. ".ply"
  end
  local plyFile = io.open(filePath, "w")
  if not plyFile then return false end

  -- Y inversion bounds
  local minY, maxY = math.huge, -math.huge
  for _, v in ipairs(voxels) do
    if v.y < minY then minY = v.y end
    if v.y > maxY then maxY = v.y end
  end
  local heightSpan = maxY - minY

  plyFile:write("ply\n")
  plyFile:write("format ascii 1.0\n")
  plyFile:write("comment Generated by Voxel Model Maker for Aseprite\n")
  plyFile:write("comment Number of voxels: " .. #voxels .. "\n")
  local numVertices = #voxels * 8
  local numFaces = #voxels * 12
  plyFile:write("element vertex " .. numVertices .. "\n")
  plyFile:write("property float x\n")
  plyFile:write("property float y\n")
  plyFile:write("property float z\n")
  plyFile:write("property uchar red\n")
  plyFile:write("property uchar green\n")
  plyFile:write("property uchar blue\n")
  plyFile:write("element face " .. numFaces .. "\n")
  plyFile:write("property list uchar int vertex_index\n")
  plyFile:write("end_header\n")
  
  -- Generate vertices and faces for all voxels
  local vertexIndex = 0
  
  -- Write vertices
  for _, voxel in ipairs(voxels) do
    -- Create cube vertices (scaled)
    local x = voxel.x * scaleModel
    local invY = (heightSpan - (voxel.y - minY)) + minY
    local y = invY * scaleModel
    local z = voxel.z * scaleModel
    local size = scaleModel
    
    -- Define 8 vertices of the cube with color
    local v1 = {x, y, z}                       -- Bottom-back-left
    local v2 = {x + size, y, z}                -- Bottom-back-right
    local v3 = {x + size, y, z + size}         -- Bottom-front-right
    local v4 = {x, y, z + size}                -- Bottom-front-left
    local v5 = {x, y + size, z}                -- Top-back-left
    local v6 = {x + size, y + size, z}         -- Top-back-right
    local v7 = {x + size, y + size, z + size}  -- Top-front-right
    local v8 = {x, y + size, z + size}         -- Top-front-left
    
    -- Color for all vertices
    local r = voxel.color.r
    local g = voxel.color.g
    local b = voxel.color.b
    
    -- Write vertex positions with colors
    plyFile:write(string.format("%f %f %f %d %d %d\n", v1[1], v1[2], v1[3], r, g, b))
    plyFile:write(string.format("%f %f %f %d %d %d\n", v2[1], v2[2], v2[3], r, g, b))
    plyFile:write(string.format("%f %f %f %d %d %d\n", v3[1], v3[2], v3[3], r, g, b))
    plyFile:write(string.format("%f %f %f %d %d %d\n", v4[1], v4[2], v4[3], r, g, b))
    plyFile:write(string.format("%f %f %f %d %d %d\n", v5[1], v5[2], v5[3], r, g, b))
    plyFile:write(string.format("%f %f %f %d %d %d\n", v6[1], v6[2], v6[3], r, g, b))
    plyFile:write(string.format("%f %f %f %d %d %d\n", v7[1], v7[2], v7[3], r, g, b))
    plyFile:write(string.format("%f %f %f %d %d %d\n", v8[1], v8[2], v8[3], r, g, b))
    
    vertexIndex = vertexIndex + 8
  end
  
  -- Write faces
  vertexIndex = 0
  for _ in ipairs(voxels) do
    local base = vertexIndex
    
    -- Write faces (triangulated quads - each face is 2 triangles)
    -- Format is: num_vertices index1 index2 index3
    
    -- Bottom face
    plyFile:write(string.format("3 %d %d %d\n", base, base + 1, base + 2))
    plyFile:write(string.format("3 %d %d %d\n", base + 2, base + 3, base))
    
    -- Top face
    plyFile:write(string.format("3 %d %d %d\n", base + 4, base + 7, base + 6))
    plyFile:write(string.format("3 %d %d %d\n", base + 6, base + 5, base + 4))
    
    -- Front face
    plyFile:write(string.format("3 %d %d %d\n", base + 3, base + 2, base + 6))
    plyFile:write(string.format("3 %d %d %d\n", base + 6, base + 7, base + 3))
    
    -- Back face
    plyFile:write(string.format("3 %d %d %d\n", base, base + 4, base + 5))
    plyFile:write(string.format("3 %d %d %d\n", base + 5, base + 1, base))
    
    -- Left face
    plyFile:write(string.format("3 %d %d %d\n", base, base + 3, base + 7))
    plyFile:write(string.format("3 %d %d %d\n", base + 7, base + 4, base))
    
    -- Right face
    plyFile:write(string.format("3 %d %d %d\n", base + 2, base + 1, base + 5))
    plyFile:write(string.format("3 %d %d %d\n", base + 5, base + 6, base + 2))
    
    vertexIndex = vertexIndex + 8
  end
  plyFile:close()
  return true
end

--------------------------------------------------------------------------------
-- Export the voxel model to STL format
-- @param voxels The voxel model to export
-- @param filePath Output file path for the STL file
-- @param options Optional export options
-- @return Boolean indicating success or failure
--------------------------------------------------------------------------------
function fileUtils.exportSTL(voxels, filePath, options)
  options = options or {}

  local scaleModel = options.scaleModel or 1.0
  
  -- Ensure file has .stl extension
  if not filePath:lower():match("%.stl$") then
    filePath = filePath .. ".stl"
  end
  
  -- Compute Y inversion bounds (fixes minY nil error)
  local minY, maxY = math.huge, -math.huge
  for _, v in ipairs(voxels) do
    if v.y < minY then minY = v.y end
    if v.y > maxY then maxY = v.y end
  end
  local heightSpan = maxY - minY
  
  -- Open file for writing
  local stlFile = io.open(filePath, "w")
  if not stlFile then
    return false, "Could not open file for writing"
  end
  
  -- Write STL header
  stlFile:write("solid voxelmodel\n")
  
  -- Process each voxel and output as triangles
  for _, voxel in ipairs(voxels) do
    -- Create cube vertices (scaled and Y-inverted)
    local x = voxel.x * scaleModel
    local invY = (heightSpan - (voxel.y - minY)) + minY
    local y = invY * scaleModel
    local z = voxel.z * scaleModel
    local size = scaleModel
    
    -- Define 8 vertices of the cube
    local v1 = {x, y, z}
    local v2 = {x + size, y, z}
    local v3 = {x + size, y, z + size}
    local v4 = {x, y, z + size}
    local v5 = {x, y + size, z}
    local v6 = {x + size, y + size, z}
    local v7 = {x + size, y + size, z + size}
    local v8 = {x, y + size, z + size}
    
    -- 12 triangles (2 per cube face)
    local triangles = {
      -- Bottom face
      {v1, v2, v3, normal = {0, -1, 0}},
      {v3, v4, v1, normal = {0, -1, 0}},
      -- Top face
      {v5, v8, v7, normal = {0, 1, 0}},
      {v7, v6, v5, normal = {0, 1, 0}},
      -- Front face
      {v4, v3, v7, normal = {0, 0, 1}},
      {v7, v8, v4, normal = {0, 0, 1}},
      -- Back face
      {v1, v5, v6, normal = {0, 0, -1}},
      {v6, v2, v1, normal = {0, 0, -1}},
      -- Left face
      {v1, v4, v8, normal = {-1, 0, 0}},
      {v8, v5, v1, normal = {-1, 0, 0}},
      -- Right face
      {v3, v2, v6, normal = {1, 0, 0}},
      {v6, v7, v3, normal = {1, 0, 0}},
    }

    for _, tri in ipairs(triangles) do
      local n = tri.normal
      stlFile:write(string.format("  facet normal %.6f %.6f %.6f\n", n[1], n[2], n[3]))
      stlFile:write("    outer loop\n")
      for i = 1, 3 do
        stlFile:write(string.format("      vertex %.6f %.6f %.6f\n",
          tri[i][1], tri[i][2], tri[i][3]))
      end
      stlFile:write("    endloop\n  endfacet\n")
    end
  end
  
  -- Write STL footer
  stlFile:write("endsolid voxelmodel\n")
  stlFile:close()
  return true
end


-- Leverage app.fs for path manipulation
fileUtils.joinPath = function(...)
  return app.fs.joinPath(...)
end

fileUtils.getFileExtension = function(path)
  return app.fs.fileExtension(path)
end

fileUtils.getFileName = function(path)
  return app.fs.fileName(path)
end

fileUtils.getFileTitle = function(path)
  return app.fs.fileTitle(path)
end

fileUtils.getDirectory = function(path)
  return app.fs.filePath(path)
end

-- Directory operations
fileUtils.isDirectory = function(path)
  return app.fs.isDirectory(path)
end

fileUtils.isFile = function(path)
  return app.fs.isFile(path)
end

fileUtils.listFiles = function(path)
  return app.fs.listFiles(path)
end

fileUtils.createDirectory = function(path)
  return app.fs.makeDirectory(path)
end

fileUtils.createDirectories = function(path)
  return app.fs.makeAllDirectories(path)
end

return fileUtils